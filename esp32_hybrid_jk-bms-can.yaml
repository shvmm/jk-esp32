# +------------------------------------------------------------------------------------------------------+
# |  JK-BMS-CAN UART+BLE Hybrid ( PYLON, Seplos, GoodWe, LuxpowerTek, SMA and Victron CANBus protocol )  |
# +------------------------------------------------------------------------------------------------------+

#     esp32_hybrid_jk-bms-can is a program to communicate with CANBus capable AIOs.

#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <https://www.gnu.org/licenses/>.

# +--------------+
# |  Changelogs  |
# +--------------+

# V1.17.3 Sleeper85 : Renumbering cells, Added “BMS Charging”, “BMS Discharging” and “JK-BMS ESP32 Restart” switches, adding Total Daily Energy sensors, set jk_bms update interval to 3s, set default log level to INFO, improvement of comments
# V1.17.2 MrPablo   : Added function "Auto Charge/Discharge Current Control" to avoid OVP/UVP alarms
# V1.17.1 Sleeper85 : New Cut-Off Current/Voltage Charging Logic for LFP with the participation of @shvmm
# V1.16.6 Sleeper85 : Selectable CAN settings + Adding inverter_offset_v + Improved CAN ID 0x355, sending 100% only at the end of the absorption phase, adding bytes [04:05] and [06:07] + Automatic calculation of the number of battery modules
# V1.16.5 Sleeper85 : Add Preventive Alarms Logic with Balancing function, CAN ID 0x356: send average temperature of T1/T2, new "Discharging current max" slider
# V1.16.4 Sleeper85 : Improved Charging Logic for ESP32 startup/reboot and Float charge, Add CAN ID 0x356 bytes [06:07] cycles for Sofar, Change switch name
# V1.16.3 Sleeper85 : ID 0x379 will be sent when choosing protocol 2 or 4 (Battery Capacity for Victron, Sol-Ark and Luxpower)
# V1.16.2 Sleeper85 : Split the "Charge/Discharge values" section and added instructions for "Stop Discharging" + Set "esp-idf" framework by default
# V1.16.1 Sleeper85 : Slider charging_current max value = ${charge_a}, Improved Alarm/Charging/Discharging Logic, Improved CAN protocol and Victron support
# V1.15.5 Sleeper85 : Improved code and set api "reboot_timout" to "0s" by default (no reboot without HA)
# V1.15.4 Sleeper85 : Improved documentation for API, Web Server and WiFi settings
# V1.15.3 Sleeper85 : Add 'CAN Protocol Settings' and new CAN ID based on the SMA and Victron protocol (alpha)
# V1.15.2 Sleeper85 : Improved Alarm handling, all alarms will set charge/discharge current to 0A and set 'Charging Status' to Alarm
# V1.15.1 Sleeper85 : New CANBUS script with CANBUS Status in HA, stop sending CAN messages if the inverter is not responding (fix WDT reboot issues)
# V1.14.3 Sleeper85 : Improved documentation + Charging Voltage tips for Deye
# V1.14.2 Sleeper85 : Improve 'Charging Voltage' behavior
# V1.14.1 Sleeper85 : Add 'Float charge function'
# V1.13.6 Sleeper85 : Add 'Absorption time' and 'Absorption Offset V.' slider
# V1.13.5 Sleeper85 : Set CAN manufacter to "PYLON" for improve compatibility with Deye and other inverters
# V1.13.4 Sleeper85 : Improve 'Charge Status' behavior + add 'Rebulk Offset V.' slider
# V1.13.3 uksa007   : Improve compatibility with Deye and other inverters
# V1.13.2 uksa007   : Send Max Temperature of T1, T2 to inverter
# V1.13.1 uksa007   : Fix compile issues with new version of ESPhome 2023.4.0, set rebulk offset to 2.5

substitutions:
# +--------------------------------------+
# name that will appear in esphome and homeassistant.
  name: shvm-jk
# +--------------------------------------+
# | Battery Charge Settings              |
# +--------------------------------------+
# This is max charging amps eg 100A, for Bulk - Constant Current charging(CC), should be at least 10A less than BMS change current protection, 0.5C max
# 100A * 50V = 5000W
  charge_a: "50"  
# Bulk / Absorption Voltage : corresponds to the Bulk voltage that will be used to charge the battery. (55.2v eg 3.45v/cell for 16 cells 48V battery)
# Float Voltage : corresponds to the voltage at which the battery would be maintained at the end of cutoff. (53.6v eg 3.35v/cell for 16 cells 48V battery)
  bulk_v: "56.4"
  float_v: "53.4"
  absorb_offset_v: "0.08"
# Rebulk voltage, voltage less than FLOAT at which BMS will rebulk, eg 53.2 V = 3.325 V/Cell
  rebulk_v: "53.0"
# Tips for Deye inverter : Add 0.1v to the inverter offset below because the Deye charging voltage is always 0.1v lower than requested.
# Absorption Offset V. : 0.08v
# Inverter offset, allows you to correct for more or lesser inverter charging voltage
# Offset = Inverter value - BMS value
# An offset of 0.1 provides an effective charging voltage at BMS of 55.2v, even when 55.1V is sent via CAN
# *** USE WITH CAUTION ***
  inverter_offset_v: "0.0"
# +--------------------------------------+
# | Battery Discharge Settings           |
# +--------------------------------------+
# Max discharge amps eg 120, should be at least 10A less than BMS over discharge current protection, 0.5C max
# 120A * 50V = 6000W
  discharge_a: "80"
# Minimum discharge voltage eg 48v/16 = 3V per cell
  min_discharge_v: "48"
# +--------------------------------------+
# | Battery State of Health (SOH)        |
# +--------------------------------------+
# Maximum charging cycles is used to calculate the battey SOH, LF280K v3 =8000.0, LF280K v2 =6000.0, LF280=3000.0 (decimal is required)
  max_cycles: "3500.0"

# High Temp Protection - Temp > OTP : Stop Charging and Discharging
  otp: "50.0"
# Low Temp Protection  - Temp < UTP : Stop Charging
  utp: "1.0"


# +--------------------------------------+
# | ESP32 CAN/TWAI/serial port pins      |
# +--------------------------------------+
# GPIO pins your CAN bus transceiver (TJA1050, TJA1051T or SN65HVD230) is connected to the ESP32 TX->TX and RX->RX !
  can_tx_pin: GPIO23
  can_rx_pin: GPIO22
# GPIO pins your JK-BMS UART-TTL is connected to the ESP32 TX->RX and RX->TX !
  tx_pin: GPIO16
  rx_pin: GPIO17

# +------------------------------------------------------------------+
# | ** The settings below can be modified according to your needs ** |
# +------------------------------------------------------------------+
  external_components_source: components
  # components
  # github://syssi/esphome-jk-bms@main
  device_description: "JK-BMS CAN using UART-TTL and BAL via BLE"

  protocol_version: JK02_24S
  mac_address: C8:47:8C:E5:20:91
  # Replace with your advertised BMS address from the BLE tracker in LOGs

esphome:
  name: ${name}
  comment: ${device_description}
  on_boot:
    then:
      - switch.turn_on: can_switch_charging
      - switch.turn_on: can_switch_discharging
      - switch.turn_on: can_switch_float
      - switch.turn_off: ble_client_switch0
      # - switch.turn_off: can_switch_auto_cvl

# +--------------------------------------+
# | ESP32 settings                       |
# +--------------------------------------+
# For a stable Bluetooth connection keep the "esp-idf" framework
esp32:
  board: esp32doit-devkit-v1
  framework:
    type: esp-idf

external_components:
  - source: ${external_components_source}
    refresh: 0s

logger:
  level: ERROR

ota:
  on_begin:
    then:
      - switch.turn_off: ble_client_switch0
      - logger.log: "BLE connection suspended for OTA update"

# Please use the native `api` component instead of the `mqtt` section.
# If you use Home Assistant, the native API is more lightweight.
# If there is no HA server connected to this API, the ESP32 reboots every 15 minutes to try to resolve the problem.
# If you don't use Home Assistant please uncomment the "reboot_timeout: 0s" option.

api:
  reboot_timeout: 0s

# In the event of problems with the WiFi network, the ESP32 will reboot every 15 minutes to try to resolve the problem.
# If we don't want to connect the ESP32 to the WiFi network please remove the 4 lines below.

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: !secret domain

web_server:
  js_url: https://attilafarago.hu/smarthome/esphome_web_server/www.js
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
  # log: false
  # ota: false
  # local: true

# +--------------------------------------+
# | ** Don't make changes below this **  |
# +--------------------------------------+

esp32_ble_tracker:
  on_ble_advertise:
    then:
      - lambda: |-
          if (x.get_name().rfind("JK-", 0) == 0 || x.get_name().rfind("JK_", 0) == 0) {
            ESP_LOGI("ble_adv", "New JK-BMS found");
            ESP_LOGI("ble_adv", "  Name: %s", x.get_name().c_str());
            ESP_LOGI("ble_adv", "  MAC address: %s", x.address_str().c_str());
            ESP_LOGD("ble_adv", "  Advertised service UUIDs:");
            for (auto uuid : x.get_service_uuids()) {
              ESP_LOGD("ble_adv", "    - %s", uuid.to_string().c_str());
            }
          }

ble_client:
  - mac_address: ${mac_address}
    id: client0

jk_bms_ble:
  - ble_client_id: client0
    protocol_version: ${protocol_version}
    throttle: 5s
    id: bmsble0

# +-----------------------+
# |  Globals declaration  |
# +-----------------------+

globals:
  - id: can_ack_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: charge_status
    type: std::string
    restore_value: no
    initial_value: '"Init"'
  - id: alarm_status
    type: std::string
    restore_value: no
    initial_value: '"NoAlarm"'
  - id: charging_v
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: charging_a
    type: float
    restore_value: no
    initial_value: '0'
  - id: discharging_a
    type: int
    restore_value: no
    initial_value: '0'
  - id: can_msg_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: eoc
    type: bool
    restore_value: no
    initial_value: "false"

output:
  - platform: gpio
    pin: 2
    id: led
    inverted: true

light:
  - platform: binary
    output: led
    id: blue_led
    name: "Blue LED"
    internal: true

# +--------------------------------------+
# | JK-BMS UART connection               |
# +--------------------------------------+

uart:
  id: uart_0
  baud_rate: 115200
  rx_buffer_size: 384
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}
  #  debug:
  #    direction: BOTH

jk_modbus:
  id: modbus0
  uart_id: uart_0
  # rx_timeout: 50ms Don't use timeout for CANBus stability.

jk_bms:
  id: bms0
  jk_modbus_id: modbus0
  # enable_fake_traffic: true

# +--------------------------------------+

# Enable time component to reset energy at midnight
# time:
#   - platform: sntp
#     id: sntp_time
time:
  - platform: homeassistant
    id: homeassistant_time

# +--------------------------------------+

button:
  - platform: jk_bms_ble
    jk_bms_ble_id: bmsble0
    retrieve_settings:
      name: "${name} retrieve settings"
    retrieve_device_info:
      name: "${name} retrieve device info"

select:
  - platform: template
    name: CAN BMS Name
    id: can_bms_name
    options:
      - "GENERAL"
      - "PYLON"
      - "GOODWE"
      - "SEPLOS"
    initial_option: "PYLON"
    optimistic: true
    set_action:
      - logger.log:
          format: "Chosen option: %s"
          args: ["x.c_str()"]
  - platform: template
    name: CAN Protocol
    id: can_protocol
    options:
      - "GENERAL"
      - "PYLON 1.2"
      - "PYLON +"
      - "SMA"
      - "VICTRON"
    initial_option: "PYLON +"
    optimistic: true
    set_action:
      - logger.log:
          format: "Chosen option: %s"
          args: ["x.c_str()"]

number:
  # +-------------+
  # | Slider      |
  # +-------------+
  - platform: template
    name: "${name} Bulk voltage"
    id: "bulk_voltage"
    step: 0.1
    min_value: 54
    max_value: 56.8
    mode: slider
    initial_value: "${bulk_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
  - platform: template
    name: "${name} Float voltage"
    id: "float_voltage"
    step: 0.1
    min_value: 52.8
    max_value: 53.6
    mode: slider
    initial_value: "${float_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
  # - platform: template
  #   name: "${name} Charging current max"
  #   id: "charging_current"
  #   step: 1
  #   min_value: 0
  #   max_value: "${charge_a}"
  #   mode: slider
  #   initial_value: "${charge_a}"
  #   unit_of_measurement: A
  #   icon: mdi:current-dc
  #   optimistic: true
  - platform: template
    name: "${name} Rebulk V."
    id: "rebulk_voltage"
    step: 0.1
    min_value: 52.4
    max_value: 53.6
    mode: slider
    initial_value: "${rebulk_v}"
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true
  - platform: jk_bms_ble
    jk_bms_ble_id: bmsble0
    balance_trigger_voltage:
      name: "${name} balance trigger voltage"
    balance_starting_voltage:
      name: "${name} balance starting voltage"

switch:
  - platform: template
    name: "${name} CAN Charge enabled"
    id: can_switch_charging
    optimistic: true
  - platform: template
    # name: "${name} CAN Discharge enabled"
    id: can_switch_discharging
    optimistic: true
  # - platform: template
  #   name: "${name} CAN Force bulk (top bal)"
  #   id: can_switch_force_bulk
  #   optimistic: true
  - platform: template
    name: "${name} CAN Float charge enabled"
    id: can_switch_float
    optimistic: true
  # - platform: template
  #   name: ${name} CAN Absorption CVL contol
  #   id: can_switch_auto_cvl
  #   optimistic: true
  
  - platform: ble_client
    ble_client_id: client0
    id: ble_client_switch0
    name: "${name} BMS Enable BT connection"
  - platform: jk_bms_ble
    jk_bms_ble_id: bmsble0
    balancer:
      name: "${name} BMS BLE balancer toggle"
  
  - platform: jk_bms
    jk_bms_id: bms0
    charging:
      id: bms_switch_charging
      name: "${name} BMS charge MOS"
    discharging:
      id: bms_switch_discharging
      # name: "${name} discharging switch"
    # balancer:
    #   name: "${name} BMS balancer UART toggle"

binary_sensor:
  - platform: jk_bms
    jk_bms_id: bms0
    balancing:
      id: equalizing
      name: "${name} balancing"
    balancing_switch:
      id: bms_switch_balancer
      # name: "${name} balancing switch"
    charging:
      name: "${name} charging"
    discharging:
      name: "${name} discharging"
    dedicated_charger_switch:
      name: "${name} dedicated charger switch"
    # online_status:
    #   name: "${name} online status"
    # +--------------------------------------+
  - platform: template
    name: "${name} CANBUS Status"
    id: can_bus_status

sensor:
  - platform: jk_bms
    jk_bms_id: bms0
    min_cell_voltage:
      id: min_cell_voltage
      name: "${name} Min cell voltage"
    max_cell_voltage:
      id: max_cell_voltage
      name: "${name} Max cell voltage"
    min_voltage_cell:
      id: min_voltage_cell
      name: "${name} Min voltage cell"
    max_voltage_cell:
      id: max_voltage_cell
      name: "${name} Max voltage cell"
    delta_cell_voltage:
      id: delta_cell_voltage
      name: "${name} cell ΔV"
    average_cell_voltage:
      name: "${name} avg cell voltage"
    cell_voltage_1:
      name: "${name} cell voltage 01"
    cell_voltage_2:
      name: "${name} cell voltage 02"
    cell_voltage_3:
      name: "${name} cell voltage 03"
    cell_voltage_4:
      name: "${name} cell voltage 04"
    cell_voltage_5:
      name: "${name} cell voltage 05"
    cell_voltage_6:
      name: "${name} cell voltage 06"
    cell_voltage_7:
      name: "${name} cell voltage 07"
    cell_voltage_8:
      name: "${name} cell voltage 08"
    cell_voltage_9:
      name: "${name} cell voltage 09"
    cell_voltage_10:
      name: "${name} cell voltage 10"
    cell_voltage_11:
      name: "${name} cell voltage 11"
    cell_voltage_12:
      name: "${name} cell voltage 12"
    cell_voltage_13:
      name: "${name} cell voltage 13"
    cell_voltage_14:
      name: "${name} cell voltage 14"
    cell_voltage_15:
      name: "${name} cell voltage 15"
    cell_voltage_16:
      name: "${name} cell voltage 16"
    # cell_voltage_17:
    #   name: "${name} cell voltage 17"
    # cell_voltage_18:
    #   name: "${name} cell voltage 18"
    # cell_voltage_19:
    #   name: "${name} cell voltage 19"
    # cell_voltage_20:
    #   name: "${name} cell voltage 20"
    # cell_voltage_21:
    #   name: "${name} cell voltage 21"
    # cell_voltage_22:
    #   name: "${name} cell voltage 22"
    # cell_voltage_23:
    #   name: "${name} cell voltage 23"
    # cell_voltage_24:
    #   name: "${name} cell voltage 24"
    power_tube_temperature:
      # id: power_tube_temperature
      name: "${name} bms temp"
    temperature_sensor_1:
      id: temperature_sensor_1
      name: "${name} batt T1"
    temperature_sensor_2:
      id: temperature_sensor_2
      name: "${name} batt T2"
    total_voltage:
      id: total_voltage
      name: "${name} Batt. Voltage"
    current:
      id: current
      name: "${name} Batt. Amps"
    power:
      id: power
      name: "${name} Batt. Power"
    charging_power:
      id: charging_power
      # name: "${name} charging power"
    discharging_power:
      id: discharging_power
      # name: "${name} discharging power"
    capacity_remaining:
      id: state_of_charge
      name: "${name} Batt. SOC"
    capacity_remaining_derived:
      id: capacity_remaining_ah
      # name: "${name} capacity remaining derived"
    # temperature_sensors:
    #   name: "${name} temperature sensors"
    charging_cycles:
      id: charging_cycles
      name: "${name} total cycle count"
    total_charging_cycle_capacity:
      name: "${name} total cycled Ah"
    battery_strings:
      id: cell_count
      # name: "${name} battery strings"
    errors_bitmask:
      id: errors_bitmask
      name: "${name} errors bitmask"
    operation_mode_bitmask:
      name: "${name} operation mode bitmask"

    # total_voltage_overvoltage_protection:
    #   name: "${name} total OVP"
    # total_voltage_undervoltage_protection:
    #   name: "${name} total UVP"
    
    # cell_voltage_overvoltage_delay:
    #   name: "${name} cell OVP delay"
    # cell_voltage_overvoltage_protection:
    #   name: "${name} cell OVP"
    # cell_voltage_overvoltage_recovery:
    #   name: "${name} cell OVP recovery"
    
    # cell_voltage_undervoltage_delay:
    #   name: "${name} cell UVP delay"
    cell_voltage_undervoltage_protection:
      id: cell_uvp
    #   name: "${name} cell UVP"
    # cell_voltage_undervoltage_recovery:
    #   name: "${name} cell UVP recovery"
    
    # Cell ΔV protection is 0.300 V
    # cell_pressure_difference_protection:
    #   name: "${name} cell ΔV protection"
    
    # discharging_overcurrent_delay:
    #   name: "${name} discharging OCP delay"
    # discharging_overcurrent_protection:
    #   name: "${name} discharging OCP"
    # charging_overcurrent_delay:
    #   name: "${name} charging OCP delay"
    # charging_overcurrent_protection:
    #   name: "${name} charging OCP"
    
    balance_starting_voltage:
      id: balance_starting_voltage
    #   name: "${name} balance starting voltage"
    balance_opening_pressure_difference:
      id: balance_trigger_voltage
    #   name: "${name} balance ΔV trigger"
    
    # MOS Temp Protection = 90 C, Recovery = 70 C
    # power_tube_temperature_protection:
    #   name: "${name} power tube temperature protection"
    # power_tube_temperature_recovery:
    #   name: "${name} power tube temperature recovery"

    # Temp sensor protection temp = 100 C
    # Temp sensor recovery temp = 100 C
    # Temp sensor difference protection = 20 C
    # temperature_sensor_temperature_protection:
    #   name: "${name} temperature sensor temperature protection"
    # temperature_sensor_temperature_recovery:
    #   name: "${name} temperature sensor temperature recovery"
    # temperature_sensor_temperature_difference_protection:
    #   name: "${name} temperature sensor temperature difference protection"

    # Charging HTP, LTP, LTR = 55, 0, 5
    # Discharging HTP, LTP, LTR = 60, -20, -10
    # 
    # charging_high_temperature_protection:
    #   name: "${name} charging high temperature protection"
    # charging_low_temperature_protection:
    #   name: "${name} charging low temperature protection"
    # charging_low_temperature_recovery:
    #   name: "${name} charging low temperature recovery"
    # discharging_high_temperature_protection:
    #   name: "${name} discharging high temperature protection"
    # discharging_low_temperature_protection:
    #   name: "${name} discharging low temperature protection"
    # discharging_low_temperature_recovery:
    #   name: "${name} discharging low temperature recovery"

    total_battery_capacity_setting:
      id: battery_capacity
      name: "${name} set battery capacity"

    # +--------------------------------------+
    # | Useful comments                      |
    # | Dev_addr = 1                         |
    # | Sleep wait = 10 s                    |
    # | Alarm low = 20%                      |
    # | Manufacturing date = NA              | 
    # +--------------------------------------+
    # current_calibration:
    #   name: "${name} current calibration"
    # device_address:
    #   name: "${name} device address"
    # sleep_wait_time:
    #   name: "${name} sleep wait time"
    # alarm_low_volume:
    #   name: "${name} alarm low volume"
    # manufacturing_date:
    #   name: "${name} manufacturing date"
    # total_runtime:
    #   name: "${name} total runtime"
    # start_current_calibration:
    #   name: "${name} start current calibration"
    # actual_battery_capacity:
    #   name: "${name} actual battery capacity"
    # protocol_version:
    #   name: "${name} protocol version"

  - platform: wifi_signal
    name: "${name} wifi Signal"
    update_interval: 60s

  # # inverse of 100 is the battery Ah
  # - platform: copy
  #   source_id: current
  #   name: ${name} BMS C-rate
  #   unit_of_measurement: "C"
  #   accuracy_decimals: 3
  #   filters:
  #     - multiply: 0.01
  

  # +--------------------------------------+
  # | Uptime sensor                        |
  # +--------------------------------------+
  - platform: uptime
    # name: "${name} Uptime Sensor"
    id: uptime_sensor
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();

  # +--------------------------------------+
  # | Template sensor                      |
  # +--------------------------------------+
  - platform: template
    name: "${name} BMS Requested CVL"
    id: requested_cvl
    unit_of_measurement: V
    device_class: voltage
  - platform: template
    name: "${name} BMS Requested CCL"
    id: requested_ccl
    unit_of_measurement: A
    device_class: current

  # +--------------------------------------+
  # | Total Daily Energy                   |
  # +--------------------------------------+
  
  - platform: total_daily_energy
    name: "${name} BMS Daily Charging Energy"
    power_id: charging_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001
  
  - platform: total_daily_energy
    name: "${name} BMS Daily Discharging Energy"
    power_id: discharging_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001
  
  # +--------------------------------------+
  # | Auto Charge Voltage Limit Control    |
  # +--------------------------------------+
  # The CVL sent will respect set bulk voltage until absorption stage is reached.
  # Once in absorption phase, the voltage will be limited so that the max_cell_voltage not increases beyond bulk voltage.
  # - platform: template
  #   name: "${name} Absorption CVL"
  #   id: absorption_cvl
  #   unit_of_measurement: V
  #   device_class: voltage
  #   accuracy_decimals: 1
  #   internal: false
  #   filters:
  #   - lambda: !lambda |-
  #             if (id(can_switch_auto_cvl) & (id(charge_status) == "Absorption")) {
  #               return (id(total_voltage).state - id(max_cell_voltage).state + id(bulk_voltage).state / id(cell_count).state);
  #             }
  #             else return (id(bulk_voltage).state);
  #   update_interval: 1s # Sensor should be updated as fast as possible!
  

text_sensor:
  - platform: jk_bms
    jk_bms_id: bms0
    errors:
      name: "${name} errors"
    operation_mode:
      name: "${name} operation mode"

    # password:
    #   name: "${name} password"

    # Battery Type = LiFePO4
    # battery_type:
    #   name: "${name} battery type"

    # device_type OR manufacturer = USER string
    # device_type:
    #   name: "${name} device type"
    # manufacturer:
    #   name: "${name} USER string"

    # software_version:
    #   name: "${name} hw/sw ver."
    total_runtime_formatted:
      name: "${name} battery age"
  
  # +--------------------------------------+
  # | Template text sensors                |
  # +--------------------------------------+
  - platform: template
    name: ${name} Uptime Human Readable
    id: uptime_human
    icon: mdi:clock-start
  - platform: template
    name: "${name} Charging Status"
    id: charging_status

# +--------------------------------------+
# | Start CAN Handling                   |
# +--------------------------------------+
canbus:
  - platform: esp32_can
    tx_pin: ${can_tx_pin}
    rx_pin: ${can_rx_pin}
    can_id: 4
    bit_rate: 500kbps
    on_frame:
    - can_id: 0x305 # Inverter ACK - SMA/LG/Pylon/Goodwe reply
      then:
        - light.toggle:
            id: blue_led
        - lambda: |-
            id(can_ack_counter) = 0;                              // Reset ACK counter
            id(can_bus_status).publish_state(true);               // Set CANBUS Status to ON
            ESP_LOGI("main", "Received CAN ID: 0x305 ACK");

interval:
  - interval: 120s
    then:
      - lambda: id(can_ack_counter) = 0;                          // Reset ACK counter for test inverter ACK
          
  - interval: 100ms
    then:
      # Start CAN Handling
      - if:
          condition:
            lambda: |-              
              if (id(can_ack_counter) < 20) {                     // Inverter ACK ? => CANBUS ON                
                id(can_ack_counter)++;                            // CANBUS ACK counter ++
                id(can_msg_counter)++;                            // CANBUS MSG counter ++
                return true;                                      // Condition OK                
              }
              else if (id(can_bus_status).state == false) {       // CANBUS already OFF ?                
                return false;                                     // Nothing to do                
              }
              else {              
                id(can_bus_status).publish_state(false);          // Set CANBUS Status to OFF
                ESP_LOGI("main", "No Rx CAN 0x305 reply, Inverter not connected/responding...");
                return false;                                     // Condition NOK                
              }

          then:
            - if:                                                                   # 0x359 Protection Alarms, Warning and Flags ( Pylontech / Goodwe / Seplos )
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((id(can_protocol).active_index() == 1) | (id(can_protocol).active_index() == 2)));
                then:
                  canbus.send: # Protection Alarms, Warning and Flags ( Pylontech / Goodwe / Seplos )
                    can_id: 0x359
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | JK-BMS errors bitmask     |
                      // +---------------------------+
                      
                      // 0x8B 0x00 0x00: Battery warning message              0000 0000 0000 0000
                      //
                      // Bit 0    Low capacity                                1 (alarm), 0 (normal)    *warning
                      // Bit 1    Power tube overtemperature                  1 (alarm), 0 (normal)    alarm
                      // Bit 2    Charging overvoltage                        1 (alarm), 0 (normal)    alarm
                      // Bit 3    Discharging undervoltage                    1 (alarm), 0 (normal)    alarm
                      // Bit 4    Battery over temperature                    1 (alarm), 0 (normal)    alarm
                      // Bit 5    Charging overcurrent                        1 (alarm), 0 (normal)    alarm
                      // Bit 6    Discharging overcurrent                     1 (alarm), 0 (normal)    alarm
                      // Bit 7    Cell pressure difference                    1 (alarm), 0 (normal)    alarm
                      // Bit 8    Overtemperature alarm in the battery box    1 (alarm), 0 (normal)    alarm
                      // Bit 9    Battery low temperature                     1 (alarm), 0 (normal)    alarm
                      // Bit 10   Cell overvoltage                            1 (alarm), 0 (normal)    alarm
                      // Bit 11   Cell undervoltage                           1 (alarm), 0 (normal)    alarm
                      // Bit 12   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 13   309_A protection                            1 (alarm), 0 (normal)    alarm
                      // Bit 14   Reserved
                      // Bit 15   Reserved
                      //
                      // Examples:
                      // 0x0001 = 00000000 00000001: Low capacity alarm
                      // 0x0002 = 00000000 00000010: MOS tube over-temperature alarm
                      // 0x0003 = 00000000 00000011: Low capacity alarm AND power tube over-temperature alarm
                      
                      // +---------------------------+
                      // | Protection : byte 0 and 1 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x400)) {                                         // High.Voltage.Alarm JK bit 2,10
                            can_mesg[0] = 0x02;                                                                        // byte0_bit1 (0x02 = bin 10)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "High.Voltage.Alarm JK bit 2,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11 
                            can_mesg[0] = can_mesg[0] | 0x04;                                                          // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // High.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x08;                                                          // byte0_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "High.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[0] = can_mesg[0] | 0x80;                                                          // byte0_bit7 (0x80 = bin 10000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS internal error JK bit 12,13
                            can_mesg[1] = can_mesg[1] | 0x08;                                                          // byte1_bit3 (0x08 = bin 1000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x80)) {                                                                  // Cell Imbalance JK bit 7
                            can_mesg[1] = can_mesg[1] | 0x10;                                                          // byte1_bit4 (0x10 = bin 10000)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[1] : %x", can_mesg[1]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";

                      // +---------------------------+
                      // | Warning : byte 2 and 3    |
                      // +---------------------------+
                      
                      can_mesg[2] = 0x00;               // byte2 (JK-BMS infos not available)
                      can_mesg[3] = 0x00;               // byte3 (JK-BMS infos not available)
                      
                      // +---------------------------+
                      // | Flags : byte 4 to 7       |
                      // +---------------------------+
                      
                      int batt_capacity = id(battery_capacity).state;
                      int batt_module;

                      if (batt_capacity <= 100) batt_module = 1;
                      else if (batt_capacity <= 200) batt_module = 2;
                      else if (batt_capacity <= 300) batt_module = 3;
                      else if (batt_capacity <= 400) batt_module = 4;
                      else if (batt_capacity <= 500) batt_module = 5;
                      else if (batt_capacity <= 600) batt_module = 6;
                      else if (batt_capacity <= 700) batt_module = 7;
                      else batt_module = 8;
                      
                      can_mesg[4] = batt_module;        // byte4 - Module in parallel
                      can_mesg[5] = 0x00;               // byte5
                      can_mesg[6] = 0x00;               // byte6
                      can_mesg[7] = 0x00;               // byte7 - DIP switches 1,3 10000100 0x84                      
                      
                      ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
 
            - if:                                                                   # 0x35A Protection Alarms and Warning ( SMA / Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 1) & ((id(can_protocol).active_index() == 3) | (id(can_protocol).active_index() == 4)));
                then:
                  canbus.send: # Protection Alarms and Warning ( SMA / Victron )
                    can_id: 0x35A
                    data: !lambda |-
                      
                      // +---------------------------+
                      // | Protection : byte 0,1,2,3 |
                      // +---------------------------+
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // JK-BMS alarm ?
                      if (id(errors_bitmask).state > 1) {
                         uint16_t jk_errormask = id(errors_bitmask).state;

                         if ((jk_errormask & 0x04) | (jk_errormask & 0x400)) {                                         // High.Voltage.Alarm JK bit 2,10
                            can_mesg[0] = 0x04;                                                                        // byte0_bit2 (0x04 = bin 100)
                            id(alarm_status) = "OVP";
                            ESP_LOGI("main", "High.Voltage.Alarm JK bit 2,10 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {                                         // Low.Voltage.Alarm JK bit 3,11
                            can_mesg[0] = can_mesg[0] | 0x10;                                                          // byte0_bit4 (0x10 = bin 10000)
                            id(alarm_status) = "UVP";
                            ESP_LOGI("main", "Low.Voltage.Alarm JK bit 3,11 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {                 // High.Temp.Alarm JK bit 1,4,8
                            can_mesg[0] = can_mesg[0] | 0x40;                                                          // byte0_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "OTP";
                            ESP_LOGI("main", "High.Temp.Alarm JK bit 1,4,8 - can_msg[0] : %x", can_mesg[0]);
                         }
                         if ((jk_errormask & 0x200)) {                                                                 // Low.Temp.Alarm JK bit 9
                            can_mesg[1] = 0x01;                                                                        // byte1_bit0 (0x01 = bin 1)
                            id(alarm_status) = "UTP";
                            ESP_LOGI("main", "Low.Temp.Alarm JK bit 9 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x40)) {                                                                  // Discharge.Over.Current JK bit 6
                            can_mesg[1] = can_mesg[1] | 0x40;                                                          // byte1_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "DOCP";
                            ESP_LOGI("main", "Discharge.Over.Current JK bit 6 - can_msg[1] : %x", can_mesg[1]);
                         }
                         if ((jk_errormask & 0x20)) {                                                                  // Charge.Over.Current JK bit 5
                            can_mesg[2] = 0x01;                                                                        // byte2_bit0 (0x01 = bin 1)
                            id(alarm_status) = "COCP";
                            ESP_LOGI("main", "Charge.Over.Current JK bit 5 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {                                      // BMS.Internal.Error JK bit 12,13
                            can_mesg[2] = can_mesg[2] | 0x40;                                                          // byte2_bit6 (0x40 = bin 1000000)
                            id(alarm_status) = "BMS";
                            ESP_LOGI("main", "BMS internal error JK bit 12,13 - can_msg[2] : %x", can_mesg[2]);
                         }
                         if (jk_errormask & 0x80) {                                                                  // Cell.Imbalance JK bit 7
                            can_mesg[3] = 0x01;                                                                        // byte3_bit0 (0x01 = bin 1)
                            ESP_LOGI("main", "Cell Imbalance JK bit 7 - can_msg[3] : %x", can_mesg[3]);
                         }
                      }
                      // No Alarm
                      else id(alarm_status) = "NoAlarm";
                      
                      ESP_LOGI("main", "send can id: 0x35A hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                     
            - if:                                                                   # 0x351 BMS instruction : Charge Volts, Charge Amps, Discharge Amps, Min voltage
                condition:
                  lambda: return id(can_msg_counter) == 2;
                then:
                  canbus.send:
                    can_id: 0x351
                    data: !lambda |-
                      
                      // +----------------------------------------------+
                      // | Cut-off Current Charging Logic for LFP       |
                      // +----------------------------------------------+

                      // Warning : information from JK BMS is not available immediately after boot
                      
                      // JK-BMS Alarm !
                      if (id(errors_bitmask).state > 1) id(charge_status) = "Alarm";
                      // JK-BMS Alarm ended
                      else if ((id(charge_status) == "Alarm") & (id(errors_bitmask).state < 2)) {
                        if (id(eoc) == true) id(charge_status) = "Cutoff";
                        else id(charge_status) = "Wait";
                      }
                      // Greedy catch for Float
                      else if ((id(charge_status) == "Cutoff") & (id(can_switch_float).state)) {
                        if (id(min_cell_voltage).state < 3.375) id(charge_status) = "Float";
                      }
                      else if ((id(charge_status) == "Float") & (!id(can_switch_float).state)) {
                        id(charge_status) = "Cutoff";
                      }

                      // +-----------------------------------------------+
                      // | Charge ON : CAN charging switch is ON         |
                      // +-----------------------------------------------+
                      else if (id(can_switch_charging).state) {
                      
                        // Cell level Variables
                        float cell_bulk_v = (id(bulk_voltage).state / id(cell_count).state);
                        float cell_rebulk_v = (id(rebulk_voltage).state / id(cell_count).state);
                        float cell_absorption_offset_v = (${absorb_offset_v} / id(cell_count).state);
                                                                        
                        // Rebulk Logic
                        if (id(max_cell_voltage).state < cell_rebulk_v) id(charge_status) = "Bulk";
                        
                        // Charging Logic for cell voltage > cell_rebulk_v
                        else if ((id(charge_status) == "Bulk") | (id(charge_status) == "Absorption") | (id(charge_status) == "Wait") | (id(charge_status) == "Init")) {
                        
                          // Charging
                          if (id(current).state > 0) { // Charging Current can't be negative for calculating cut-off voltage

                            /* CVmin = 3.375, CVmax = 3.625, Charge_Rate = 0.05 C
                             * cutoff_voltage constant: (CVmax - CVmin) ÷ Charge_Rate = 5                                 # Voltages are in numerator
                             * cutoff_current constant: 1 ÷ cutoff_voltage constant = Charge_Rate ÷ (CVmax - CVmin) = 0.2
                             */

                            float cutoff_current = (id(battery_capacity).state * 0.5 * (cell_bulk_v - 3.375)); // FIXED for loop initiation!
                            float cutoff_voltage = (3.375 + 2 * (id(current).state / id(battery_capacity).state));
                            
                            ESP_LOGI("main", "Cut-Off Current : %f", cutoff_current);
                            ESP_LOGI("main", "Cut-Off Voltage : %f", cutoff_voltage);

                            // Charge termination
                            if ((id(current).state < cutoff_current) & (id(max_cell_voltage).state > cutoff_voltage)) {
                              id(charge_status) = "Cutoff";
                              // Balancer to be toggled on at this stage and BMS charge MOS toggled OFF; Charger needs to be put into rest mode.
                            }
                            // Continue Charging
                            else {
                              if (id(max_cell_voltage).state > (cell_bulk_v - cell_absorption_offset_v)) id(charge_status) = "Absorption";
                              // Bulk
                              else id(charge_status) = "Bulk";
                            }
                          }
                          // Discharging (!= "Cutoff" | != "Float")
                          else id(charge_status) = "Bulk";
                        }
                      }
                      // Charge OFF
                      else id(charge_status) = "Wait";

                      // +--------------------------------------+
                      // | Instruct Charge values : Final       |
                      // +--------------------------------------+

                      // Bulk Charge
                      if ((id(charge_status) == "Bulk") | (id(charge_status) == "Absorption")) {
                        id(charging_v) = (id(bulk_voltage).state + ${inverter_offset_v});
                        id(charging_a) = ${charge_a};
                        id(eoc) = false;
                      }

                      else if (id(charge_status) == "Float") {
                        id(charging_v) = id(float_voltage).state;
                        id(charging_a) = ${charge_a};
                      }                    
                      // Cutoff (EOC) : Not allowed to charge further. Targets ReBulk but with 0 current
                      else if (id(charge_status) == "Cutoff") {
                        id(charging_v) = id(float_voltage).state;
                        id(charging_a) = 0.0;
                        id(eoc) = true; // SOC 100% can be sent
                        // Turn Off BMS Charge MOS
                        // Balancer can turn on
                      }
                      // Wait : Stop Charging
                      else if (id(charge_status) == "Wait") {
                        id(charging_v) = id(rebulk_voltage).state;
                        id(charging_a) = 0;
                      }
                      
                      // +--------------------------------------+
                      // | Discharge values : Final             |
                      // | Priority for checking DCL values:    |
                      // | BMS+ESP switch --> Minimum Voltage   |
                      // +--------------------------------------+

                      // Stop Discharging if BMS or ESP32 switch is OFF
                      if ((!id(bms_switch_discharging).state) | (!id(can_switch_discharging).state)) id(discharging_a) = 0;
                      // Stop Discharging if battery voltage is low
                      else if (id(total_voltage).state < ${min_discharge_v}) id(discharging_a) = 0;
                      // Allow Discharging
                      else id(discharging_a) = ${discharge_a};

                      // +--------------------------------------+
                      // | Preventive Alarms Logic : Final      |
                      // +--------------------------------------+

                      // High Temp Protection - Stop Charging and Discharging
                      if (max(id(temperature_sensor_1).state, id(temperature_sensor_2).state) > ${otp}){
                        id(alarm_status) = "OTP";
                      }
                      // Low Temp Protection - Stop Charging
                      else if (min(id(temperature_sensor_1).state, id(temperature_sensor_2).state) < ${utp}){
                        id(alarm_status) = "UTP";
                      }

                      // +--------------------------------------+
                      // | Alarm overwrite values : Final       |
                      // +--------------------------------------+

                      ESP_LOGI("main", "Alarm Status : %s", id(alarm_status).c_str());
                      
                      // Alarm : Stop Both Charging and Discharging
                      if ((id(alarm_status) == "OTP") | (id(alarm_status) == "BMS")){
                          id(charging_v) = 3.2 * id(cell_count).state;
                          id(charging_a) = 0;
                          id(discharging_a) = 0;
                      }
                      // Alarm : Stop Charging while allowing Discharging
                      else if ((id(alarm_status) == "OVP") | (id(alarm_status) == "UTP") | (id(alarm_status) == "COCP")){
                          id(charging_v) = 3.2 * id(cell_count).state;
                          id(charging_a) = 0;
                      }
                      // Alarm : Stop Discharging while allowing Charging
                      else if ((id(alarm_status) == "UVP") | (id(alarm_status) == "DOCP")){
                          id(discharging_a) = 0;
                      }
                      
                      // +--------------------------------------+
                      // | CAN messages : Final                 |
                      // +--------------------------------------+
                      
                      // Byte [00:01] = CVL : Charge Limit Voltage
                      // Byte [02:03] = CCL : Charge Limit Current
                      // Byte [04:05] = DCL : Discharge Limit Current
                      // Byte [06:07] = DVL : Discharge Limit Voltage
                      
                      uint8_t can_mesg[8];
                      
                      can_mesg[0] = uint16_t(id(charging_v) * 10) & 0xff;
                      can_mesg[1] = uint16_t(id(charging_v) * 10) >> 8 & 0xff;
                      can_mesg[2] = uint16_t(id(charging_a) * 10) & 0xff;
                      can_mesg[3] = uint16_t(id(charging_a) * 10) >> 8 & 0xff;
                      can_mesg[4] = uint16_t(id(discharging_a) * 10) & 0xff;
                      can_mesg[5] = uint16_t(id(discharging_a) * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(${min_discharge_v} * 10) & 0xff;
                      can_mesg[7] = uint16_t(${min_discharge_v} * 10) >> 8 & 0xff;
                      
                      // +--------------------------------------+
                      // | Publish sensor state : Final         |
                      // +--------------------------------------+
                      
                      id(charging_status).publish_state(id(charge_status));                      
                      id(requested_cvl).publish_state(id(charging_v));
                      id(requested_ccl).publish_state(id(charging_a));
                      
                      // Logs
                      ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      ESP_LOGI("main", "Charge Status : %s", id(charge_status).c_str());
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:                                                                   # 0x355 Actual State of Charge (SOC) / State of Health (SOH), 0% SOH means 80% of new capacity.
                condition:
                  lambda: return id(can_msg_counter) == 3;
                then:
                  canbus.send:
                    can_id: 0x355
                    data: !lambda |-
                      // Byte [00:01] : State of Charge (SOC)    (1 %)
                      // Byte [02:03] : State of Health (SOH)    (1 %)
                      // Byte [04:05] : SOC high resolution      (0.01 %)
                      // Byte [06:07] : Remaining total capacity (1 Ah) (Sofar)

                      uint8_t can_mesg[8];
                      uint16_t soc;
                      uint16_t soh;

                      // SOC - Sending 100% only at the end of the absorption phase
                      if (id(state_of_charge).state < 100) soc = id(state_of_charge).state;       // SOC < 100% => Sending BMS SOC
                      else if (id(eoc) == true) soc = 100;                                        // End Of Charge => Sending 100%
                      else soc = 99;  

                      // SOH
                      soh = round(1 - ((id(charging_cycles).state / ${max_cycles})) * 100);
                      // soh = round(100 * (0.8 ** (id(charging_cycles).state/${max_cycles})));
                      
                      can_mesg[0] = soc & 0xff;
                      can_mesg[1] = soc >> 8 & 0xff;
                      can_mesg[2] = soh & 0xff;
                      can_mesg[3] = soh >> 8 & 0xff;
                      can_mesg[4] = (soc * 100) & 0xff;
                      can_mesg[5] = (soc * 100) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(capacity_remaining_ah).state * 10) & 0xff;
                      can_mesg[7] = uint16_t(id(capacity_remaining_ah).state * 10) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:                                                                   # 0x356 Actual Voltage / Current / Temperature / Cycles (Deye 0x305 ACK)
                condition:
                  lambda: return id(can_msg_counter) == 4;
                then:
                  canbus.send:
                    can_id: 0x356
                    data: !lambda |-
                      
                      // Byte [00:01] : Actual Voltage
                      // Byte [02:03] : Actual Current
                      // Byte [04:05] : Actual Temperature
                      // Byte [06:07] : Actual Cycles number (Sofar)

                      uint8_t can_mesg[8];
                      can_mesg[0] = uint16_t(id(total_voltage).state * 100) & 0xff;
                      can_mesg[1] = uint16_t(id(total_voltage).state * 100) >> 8 & 0xff;
                      can_mesg[2] = int16_t(id(current).state * 10) & 0xff;
                      can_mesg[3] = int16_t(id(current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[5] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(charging_cycles).state) & 0xff;
                      can_mesg[7] = uint16_t(id(charging_cycles).state) >> 8 & 0xff;    
                      ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:                                                                   # 0x35C Request flag to Enable/Disable: Charge, Discharge ( Pylontech / Goodwe / Seplos )
                condition:
                  lambda: return ((id(can_msg_counter) == 5) & ((id(can_protocol).active_index() == 1) | (id(can_protocol).active_index() == 2)));
                then:
                  canbus.send: # Request flag to Enable/Disable: Charge, Discharge ( Pylontech / Goodwe / Seplos )
                    can_id: 0x35C
                    data: !lambda |-
                      uint8_t can_mesg[2];
                      can_mesg[0] = 0x00;
                      can_mesg[1] = 0x00;
                      
                      // Bit 7 : Charge enable
                      if (id(can_switch_charging).state)
                         can_mesg[0] = 0x80;
                      
                      // Bit 6 : Discharge enable
                      if ((id(bms_switch_discharging).state) & (id(can_switch_discharging).state))
                         can_mesg[0] = can_mesg[0] | 0x40;
                                            
                      ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                      return {can_mesg[0], can_mesg[1]};
                      
            - if:                                                                   # 0x70  Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V ( Pylontech / Goodwe / Seplos )
                condition:
                  lambda: return ((id(can_msg_counter) == 6) & (id(can_protocol).active_index() == 2));
                then:
                  canbus.send:
                    can_id: 0x70
                    data: !lambda |-
                      
                      // Byte [00:01] : Max cell temperature
                      // Byte [02:03] : Min cell temperature
                      // Byte [04:05] : Max cell voltage
                      // Byte [06:07] : Min cell voltage
                      
                      int max_cell_voltage_i = id(max_cell_voltage).state * 100.0;
                      int min_cell_voltage_i = id(min_cell_voltage).state * 100.0;
                      uint8_t can_mesg[8];
                      can_mesg[0] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[1] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[2] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[3] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[4] = max_cell_voltage_i & 0xff;
                      can_mesg[5] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[6] = min_cell_voltage_i & 0xff;
                      can_mesg[7] = min_cell_voltage_i >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:                                                                   # 0x371 Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID ( Pylontech / Goodwe / Seplos )
                condition:
                  lambda: return ((id(can_msg_counter) == 6) & (id(can_protocol).active_index() == 2));
                then:
                  - canbus.send:
                      can_id: 0x371
                      data: !lambda |-
                        
                        // Byte [00:01] : Max cell temperature ID
                        // Byte [02:03] : Min cell temperature ID
                        // Byte [04:05] : Max cell voltage ID
                        // Byte [06:07] : Min cell voltage ID
                        
                        uint8_t can_mesg[8];

                        // Min-Max Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state >= id(temperature_sensor_2).state){
                          can_mesg[0] = 0x01;
                          can_mesg[2] = 0x02;
                        }
                        else {
                          can_mesg[0] = 0x02;
                          can_mesg[2] = 0x01;
                        }
                        
                        can_mesg[1] = 0x00;
                        can_mesg[3] = 0x00;
                        can_mesg[4] = uint16_t(id(max_voltage_cell).state) & 0xff;
                        can_mesg[5] = uint16_t(id(max_voltage_cell).state) >> 8 & 0xff;
                        can_mesg[6] = uint16_t(id(min_voltage_cell).state) & 0xff;
                        can_mesg[7] = uint16_t(id(min_voltage_cell).state) >> 8 & 0xff;
                        ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:                                                                   # 0x372 Battery modules information ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 7) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      can_id: 0x372
                      data: !lambda |-
                        
                        // Byte [00:01] : Nbr. of battery modules online
                        // Byte [02:03] : Nbr. of modules blocking charge
                        // Byte [04:05] : Nbr. of modules blocking discharge
                        // Byte [06:07] : Nbr. of battery modules offline
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = 0x01;

                        ESP_LOGI("main", "send can id: 0x372 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if:                                                                   # 0x373 Actual Min Cell V, Max Cell V, Min Cell Temp (Kelvin), Max Cell Temp (Kelvin) ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  canbus.send:                                                      # Actual Min Cell V, Max Cell V, Min Cell Temp (Kelvin), Max Cell Temp (Kelvin) ( Victron )
                    can_id: 0x373
                    data: !lambda |-
                      
                      // Byte [00:01] : Min cell voltage
                      // Byte [02:03] : Max cell voltage
                      // Byte [04:05] : Min cell temperature
                      // Byte [06:07] : Max cell temperature
                      
                      int min_cell_voltage_i = id(min_cell_voltage).state * 1000.0;
                      int max_cell_voltage_i = id(max_cell_voltage).state * 1000.0;
                      int min_temp_kelvin = min(id(temperature_sensor_1).state, id(temperature_sensor_2).state) + 273.15;
                      int max_temp_kelvin = max(id(temperature_sensor_1).state, id(temperature_sensor_2).state) + 273.15;
                      
                      uint8_t can_mesg[8];
                      can_mesg[0] = min_cell_voltage_i & 0xff;
                      can_mesg[1] = min_cell_voltage_i >> 8 & 0xff;
                      can_mesg[2] = max_cell_voltage_i & 0xff;
                      can_mesg[3] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[4] = min_temp_kelvin & 0xff;
                      can_mesg[5] = min_temp_kelvin >> 8 & 0xff;
                      can_mesg[6] = max_temp_kelvin & 0xff;
                      can_mesg[7] = max_temp_kelvin >> 8 & 0xff;
                      
                      ESP_LOGI("main", "send can id: 0x373 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:                                                                   # 0x374 Min cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:                                                    # Min cell voltage ID [ASCII] ( Victron )
                      can_id: 0x374
                      data: !lambda |-
                        
                        int cell_id = id(min_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x374 [ASCII] Min cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if:                                                                   # 0x375 Max cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:                                                    # Max cell voltage ID [ASCII] ( Victron )
                      can_id: 0x375
                      data: !lambda |-
                        
                        int cell_id = id(max_voltage_cell).state;

                        ESP_LOGI("main", "send can id: 0x375 [ASCII] Max cell voltage ID : %i", cell_id);

                        if (cell_id == 1) return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 2) return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 3) return {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 4) return {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 5) return {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 6) return {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 7) return {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 8) return {0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 9) return {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 10) return {0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 11) return {0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 12) return {0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 13) return {0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 14) return {0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 15) return {0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else if (cell_id == 16) return {0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        else return {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            - if:                                                                   # 0x376 Min cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:                                                    # Min cell temperature ID [ASCII] ( Victron )
                      can_id: 0x376
                      data: !lambda |-
                        
                        // Min Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state > id(temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if:                                                                   # 0x377 Max cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 8) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:                                                    # Max cell temperature ID [ASCII] ( Victron )
                      can_id: 0x377
                      data: !lambda |-
                        
                        // Max Temp. Sensor ID ?
                        if (id(temperature_sensor_1).state > id(temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if:                                                                   # 0x379 Battery Installed Capacity Ah ( Victron, Sol-Ark, Luxpower )
                condition:
                  lambda: return ((id(can_msg_counter) == 9) & ((id(can_protocol).active_index() == 2) | (id(can_protocol).active_index() == 4)));
                then:
                  - canbus.send:                                                    # Battery Installed Capacity Ah ( Victron, Sol-Ark, Luxpower )
                      can_id: 0x379
                      data: !lambda |-
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = uint16_t(id(battery_capacity).state) & 0xff;
                        can_mesg[1] = uint16_t(id(battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x379 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:                                                                   # 0x382 Product identification [ASCII] ( Victron )
                condition:
                  lambda: return ((id(can_msg_counter) == 10) & (id(can_protocol).active_index() == 4));
                then:
                  - canbus.send:                                                    # Product identification [ASCII] ( Victron )
                      can_id: 0x382
                      data: !lambda |-
                        ESP_LOGI("main", "send can id: 0x382 [ASCII] Product : JK-BMS");
                        return {0x4A, 0x4B, 0x2D, 0x42, 0x4D, 0x53, 0x00, 0x00}; // JK-BMS

            - if:                                                                   # 0x35F Send Battery info
                condition:
                  lambda: return ((id(can_msg_counter) == 11) & ((id(can_protocol).active_index() == 3) | (id(can_protocol).active_index() == 4)));
                then:
                  - canbus.send:                                                    # Battery information ( SMA, Victron )
                      can_id: 0x35F
                      data: !lambda |-
                        
                        //                SMA                 Victron
                        // Byte [00:01] : Bat-Type            Product ID
                        // Byte [02:03] : BMS Version         Firmware version (1.17 => HEX [01:11])
                        // Byte [04:05] : Bat-Capacity        Available Capacity Ah
                        // Byte [06:07] : Manufacturer ID     Hardware version
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[2] = 0x01;
                        can_mesg[3] = 0x11;
                        can_mesg[4] = uint16_t(id(battery_capacity).state) & 0xff;
                        can_mesg[5] = uint16_t(id(battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x35F hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:                                                                   # 0x35E Send BMS Name
                condition:
                  lambda: return id(can_msg_counter) == 12;
                then:
                  - canbus.send:
                      can_id: 0x35E                                                 # Manufacturer name
                      data: !lambda |-
                        if (id(can_bms_name).active_index() == 0){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GENERAL");
                           return {0x47, 0x45, 0x4E, 0x45, 0x52, 0x41, 0x4C, 0x20}; // GENERAL
                        }
                        if (id(can_bms_name).active_index() == 1){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON ( recognized by Deye, display PYLON name and SOH )
                        }
                        else if (id(can_bms_name).active_index() == 2){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GOODWE");
                           return {0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20}; // GOODWE
                        }
                        else if (id(can_bms_name).active_index() == 3){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SHEnergy");
                           return {0x53, 0x48, 0x45, 0x6E, 0x65, 0x72, 0x67, 0x79}; // SHEnergy (SEPLOS)
                        }
                        else {
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON
                        }
                    # Reset counter
                  - lambda: id(can_msg_counter) = 0;
